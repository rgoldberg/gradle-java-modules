/*
 * Copyright 2017 - 2020 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.gradle.java.extension


import java.io.File
import java.io.File.pathSeparator
import kotlinx.collections.immutable.persistentSetOf
import kotlinx.collections.immutable.toImmutableSet
import org.gradle.api.JavaVersion
import org.gradle.api.file.ConfigurableFileCollection
import org.gradle.api.reflect.TypeOf.typeOf
import org.gradle.api.tasks.compile.JavaCompile
import org.gradle.api.tasks.testing.Test
import org.gradle.java.JigsawPlugin
import org.gradle.java.jdk.JAVAC
import org.gradle.java.testing.isTestInput
import org.gradle.java.testing.moduleNameIset
import org.gradle.java.util.getCompileSourceSet
import org.gradle.java.util.getCompileSourceSetName
import org.gradle.java.util.sourceSets


interface JavaCompileOptions: SourceJavaOptions, AutoGenerateSettableCascading {

    override val addModules:       AutoGeneratableSeparableValueVarargOption<String>
    override val modulePath:       AutoGeneratableSeparableValueVarargOption<String>
    override val moduleSourcePath: AutoGeneratableSeparableValueVarargOption<String>
    override val addReads:         AutoGeneratableSeparableValueKeyedVarargOption<String, String>
    override val patchModule:      AutoGeneratableSeparableValueKeyedVarargOption<String, String>

    val target: ScalarOption<JavaVersion?>

    val moduleVersion:                SeparableValueScalarOption<String?>
    val defaultModuleForCreatedFiles: SeparableValueScalarOption<String?>

    val processorModulePath: SeparableValueVarargOption<String>

    fun preferNewer()
    fun preferSource()
}


open class JavaCompileOptionsInternal(
                 autoGenerateParent:  AutoGenerateGettable,
                separateValueParent: SeparateValueGettable,
    private val         javaCompile: JavaCompile
):
JavaCompileOptions,
AutoGeneratableCascading by DefaultAutoGeneratableCascading( autoGenerateParent),
 SeparableValueCascading by  DefaultSeparableValueCascading(separateValueParent),
SourceJavaOptionsInternal() {

    //TODO?
    // -Xlint:
    //    exports
    //    module
    //    opens
    //    requires-automatic
    //    requires-transitive-automatic

    override fun getPublicType() =
        PUBLIC_TYPE


    override val args = {
        val options = javaCompile.options

        val argMlist = options.compilerArgs.toMutableList()

        options.compilerArgs = argMlist

        ListArgAppendable(argMlist)
    }()

    override fun config() {
        super.config()

        args
        .appendSeparated(target)
        .append(moduleVersion)
        .append(defaultModuleForCreatedFiles)
        .appendJoined(prefer)
        .append(processorModulePath)
    }


    override val target = DefaultScalarOptionInternal<JavaVersion?>(JAVAC.OPTION_TARGET, null)

    override val moduleVersion by lazy {
        DefaultSeparableValueScalarOptionInternal<String?>(JAVAC.OPTION_MODULE_VERSION,                   "=", null, this)
    }

    override val defaultModuleForCreatedFiles by lazy {
        DefaultSeparableValueScalarOptionInternal<String?>(JAVAC.OPTION_DEFAULT_MODULE_FOR_CREATED_FILES, "=", null, this)
    }

    override val processorModulePath by lazy {
        DefaultSeparableValueSetOptionInternal<String>(JAVAC.OPTION_PROCESSOR_MODULE_PATH, "=", pathSeparator, this)
    }

    private val prefer = DefaultScalarOptionInternal<String?>(JAVAC.OPTION_PREFER, null)
    override fun preferNewer() {
        prefer(null)
    }
    override fun preferSource() {
        prefer(JAVAC.SOURCE)
    }

    override val addModules: AutoGeneratableSeparableValueSetOptionInternal<String> by lazy {
        object:
        AutoGeneratableSeparableValueSetOptionInternal<String>,
        AddModules(),
        AutoGeneratableCascading by DefaultAutoGeneratableCascading(this) {
            override val value: Set<String>
            get() =
                super.value.appendAutoGeneratedIterator(autoGenerate.isEnabled && javaCompile.isTestInput) {
                    //TODO: ensure works
                    //TODO: only use Test for javaCompile instead of all Tests
                    javaCompile.project.tasks.withType(Test::class.java).asSequence()
                    .flatMap {it.moduleNameIset.asSequence()}
                    .iterator()
                }
        }
    }

    override val modulePath: AutoGeneratableSeparableValueSetOptionInternal<String> by lazy {
        object:
        AutoGeneratableSeparableValueSetOptionInternal<String>,
        ModulePath(),
        AutoGeneratableCascading by DefaultAutoGeneratableCascading(this) {
            override val value: Set<String>
            get() =
                super.value.appendAutoGeneratedIterator(autoGenerate.isEnabled) {
                    //TODO: ensure works
                    val project = javaCompile.project

                    val sourceSetName = javaCompile.getCompileSourceSetName(TARGET)

                    when {
                        project.plugins.getPlugin(JigsawPlugin::class.java).getModuleNameIbyModuleInfoJavaPath(sourceSetName).isNotEmpty() -> {
                            // source set contains at least one module-info.java
                            //TODO: FILTER BASED ON PRESENCE OF MODULE
                            javaCompile.autoGenerateModulePath(javaCompile.classpath)
                        }
                        javaCompile.isTestInput -> {
                            // when source set doesn't contain any module-info.java, only enable modules if compiling a test source set
                            javaCompile.autoGenerateModulePath(javaCompile.classpath + project.sourceSets.getByName(sourceSetName).allJava.sourceDirectories)
                        }
                        else -> {
                            persistentSetOf<String>().iterator()
                        }
                    }
                }
        }
    }

    override val moduleSourcePath: AutoGeneratableSeparableValueSetOptionInternal<String> by lazy {
        object:
        AutoGeneratableSeparableValueSetOptionInternal<String>,
        ModuleSourcePath(),
        AutoGeneratableCascading by DefaultAutoGeneratableCascading(this) {
            override val value: Set<String>
            get() =
                super.value.appendAutoGeneratedCollection(autoGenerate.isEnabled) {
                    val moduleNameIbyModuleInfoJavaPath =
                        javaCompile.project.plugins.getPlugin(JigsawPlugin::class.java)
                        .getModuleNameIbyModuleInfoJavaPath(javaCompile.getCompileSourceSetName(TARGET))

                    if (moduleNameIbyModuleInfoJavaPath.size < 2) {
                        persistentSetOf()
                    }
                    else {
                        //TODO: determine the packages for each module, and include root dir for all sources in that package

                        // must change the classes output directories for the SourceSet:
                        // for each existing output directory, d, replace with subdirectories of d, one for each compile module name

                        //TODO: only works if SourceSet#output#classesDirs is a ConfigurableFileCollection
                        val outputClassesDirs = javaCompile.getCompileSourceSet(TARGET).output.classesDirs as ConfigurableFileCollection

                        //TODO: ensure it is OK to change SourceSet#output#classesDirs during execution phase
                        outputClassesDirs.setFrom(
                            outputClassesDirs.asSequence()
                            .flatMap {dirFile -> moduleNameIbyModuleInfoJavaPath.values.asSequence().map {File(dirFile, it)}}
                            .asIterable()
                        )

                        autoGenerateModuleSourcePath(
                            moduleNameIbyModuleInfoJavaPath.entries.asSequence()
                            .map {
                                val moduleInfoJavaPath          = it.key
                                val moduleName                  = it.value
                                val separator                   = moduleInfoJavaPath.fileSystem.separator
                                val moduleInfoJavaDirPathString = moduleInfoJavaPath.parent.toString()

                                val i = moduleInfoJavaDirPathString.lastIndexOf(separator + moduleName + separator)

                                if (i == -1) {
                                    if (moduleInfoJavaDirPathString.endsWith(separator + moduleName)) {
                                        moduleInfoJavaDirPathString.substring(0, moduleInfoJavaDirPathString.length - separator.length - moduleName.length)
                                    }
                                    else {
                                        moduleInfoJavaDirPathString
                                    }
                                }
                                else {
                                    StringBuilder(moduleInfoJavaDirPathString.length - moduleName.length + 1)
                                    .append(moduleInfoJavaDirPathString, 0, i + separator.length)
                                    .append('*')
                                    .append(
                                        moduleInfoJavaDirPathString,
                                        i + separator.length + moduleName.length,
                                        moduleInfoJavaDirPathString.length
                                    )
                                    .toString()
                                }
                            }
                            .toSortedSet()
                            .toImmutableSet()
                        )
                    }
                }
        }
    }

    override val addReads: AutoGeneratableSeparableValueLinkedHashMultimapOptionInternal<String, String> by lazy {
        object:
        AutoGeneratableSeparableValueLinkedHashMultimapOptionInternal<String, String>,
        AddReads(),
        AutoGeneratableCascading by DefaultAutoGeneratableCascading(this) {
            override val value: Map<String, Set<String>>
            get() {
                val project by lazy {
                    javaCompile.project
                }

                val moduleNameIset by lazy {
                    project.plugins.getPlugin(JigsawPlugin::class.java).moduleNameIset
                }

                val valueSet by lazy {
                    project.tasks.withType(Test::class.java).asSequence()
                    .flatMap {it.moduleNameIset.asSequence()}
                    .toCollection(createCollection())
                }

                return valueMutable.appendAutoGeneratedMapFromPairIterator(
                       autoGenerate  .isEnabled
                    && javaCompile   .isTestInput
                    && moduleNameIset.isNotEmpty()
                    && valueSet      .isNotEmpty()
                ) {
                    //TODO: ensure works
                    //TODO: only use Test for javaCompile instead of all Tests
                    moduleNameIset.asSequence()
                    .map {it to valueSet}
                    .iterator()
                }
            }
        }
    }

    override val patchModule: AutoGeneratableSeparableValueLinkedHashMultimapOptionInternal<String, String> by lazy {
        object:
        AutoGeneratableSeparableValueLinkedHashMultimapOptionInternal<String, String>,
        PatchModule(),
        AutoGeneratableCascading by DefaultAutoGeneratableCascading(this) {
            override val value: Map<String, Set<String>>
            get() =
                valueMutable.appendAutoGeneratedMapFromPair(autoGenerate.isEnabled) {
                    val project = javaCompile.project

                    val sourceSetName = javaCompile.getCompileSourceSetName(TARGET)

                    val moduleNameIbyModuleInfoJavaPath = project.plugins.getPlugin(JigsawPlugin::class.java).getModuleNameIbyModuleInfoJavaPath(sourceSetName)

                    when {
                        moduleNameIbyModuleInfoJavaPath.isNotEmpty() -> {
                            // source set contains at least one module-info.java
                            //TODO: FILTER BASED ON PRESENCE OF MODULE
                            autoGeneratePatchModule(moduleNameIbyModuleInfoJavaPath.values, javaCompile.classpath)
                        }
                        javaCompile.isTestInput -> {
                            // when source set doesn't contain any module-info.java, only enable modules if compiling a test source set
                            autoGeneratePatchModule(
                                project.plugins.getPlugin(JigsawPlugin::class.java).moduleNameIset,
                                javaCompile.classpath + project.sourceSets.getByName(sourceSetName).allJava.sourceDirectories
                            )
                        }
                        else -> {
                            null
                        }
                    }
                }
        }
    }


    companion object {
        private val PUBLIC_TYPE = typeOf(JavaCompileOptions::class.java)

        private const val TARGET = "Java"
    }
}
